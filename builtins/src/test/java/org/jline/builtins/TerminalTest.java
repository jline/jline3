/*
 * Copyright (c) 2002-2025, the original author(s).
 *
 * This software is distributable under the BSD license. See the terms of the
 * BSD license in the documentation provided with this software.
 *
 * https://opensource.org/licenses/BSD-3-Clause
 */
package org.jline.builtins;

import java.awt.*;
import java.io.IOException;
import javax.swing.*;

import org.jline.terminal.Size;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for WebTerminal and SwingTerminal implementations.
 */
public class TerminalTest {

    private WebTerminal webTerminal;
    private SwingTerminal swingTerminal;

    @BeforeEach
    public void setUp() throws IOException {
        // Create terminals with small sizes for testing
        webTerminal = new WebTerminal("localhost", 0, 20, 10); // Port 0 = random available port
        swingTerminal = new SwingTerminal(20, 10);
    }

    @AfterEach
    public void tearDown() {
        if (webTerminal != null && webTerminal.isRunning()) {
            webTerminal.stop();
        }
        if (swingTerminal != null) {
            swingTerminal.dispose();
        }
    }

    @Test
    public void testWebTerminalCreation() {
        assertNotNull(webTerminal);
        assertFalse(webTerminal.isRunning());
        assertTrue(webTerminal.getUrl().startsWith("http://localhost:"));
    }

    @Test
    public void testWebTerminalStartStop() throws IOException {
        assertFalse(webTerminal.isRunning());

        webTerminal.start();
        assertTrue(webTerminal.isRunning());

        webTerminal.stop();
        assertFalse(webTerminal.isRunning());
    }

    @Test
    public void testWebTerminalWriteAndRead() {
        webTerminal.write("Hello, World!");
        String output = webTerminal.read();
        // read() returns escape sequences, not the original text
        assertNotNull(output);
    }

    @Test
    public void testWebTerminalPipe() {
        String input = "test input";
        String piped = webTerminal.pipe(input);
        assertNotNull(piped);
        assertEquals(input, piped); // Simple input should pass through unchanged
    }

    @Test
    public void testWebTerminalSpecialKeys() {
        // Test special key handling - pipe method processes input
        String arrowUp = webTerminal.pipe("~A");
        // The pipe method should process the special key sequence
        assertNotNull(arrowUp);

        String enter = webTerminal.pipe("\r");
        // The pipe method should process carriage return
        assertNotNull(enter);
        // Note: The exact output depends on the terminal's newline mode
        // In some modes it might be just "\r", in others "\r\n"
    }

    @Test
    public void testSwingTerminalCreation() {
        assertNotNull(swingTerminal);
        assertNotNull(swingTerminal.getComponent());

        SwingTerminal.TerminalComponent component = swingTerminal.getComponent();
        assertTrue(component.isFocusable());
        assertNotNull(component.getTerminalFont());
    }

    @Test
    public void testSwingTerminalComponent() {
        SwingTerminal.TerminalComponent component = swingTerminal.getComponent();

        // Test font setting
        Font originalFont = component.getTerminalFont();
        Font newFont = new Font(Font.MONOSPACED, Font.BOLD, 16);
        component.setTerminalFont(newFont);
        assertEquals(newFont, component.getTerminalFont());

        // Test preferred size calculation
        Dimension preferredSize = component.getPreferredSize();
        assertTrue(preferredSize.width > 0);
        assertTrue(preferredSize.height > 0);
    }

    @Test
    public void testSwingTerminalInput() {
        SwingTerminal.TerminalComponent component = swingTerminal.getComponent();

        // Test that input queue is initially empty
        assertNull(component.pollInput());

        // Simulate key input (this is limited in unit tests without actual key events)
        // In a real application, key events would be generated by user interaction
    }

    @Test
    public void testSwingTerminalWriteAndDisplay() {
        swingTerminal.write("Hello, Swing Terminal!");

        // Verify that the terminal has been marked as dirty
        assertTrue(swingTerminal.isDirty());

        // Test that we can get screen data
        long[] screenData = new long[20 * 10]; // width * height
        int[] cursor = new int[2];
        swingTerminal.dump(screenData, 0, 0, 10, 20, cursor);

        // Should have some non-space characters
        boolean hasContent = false;
        for (long cell : screenData) {
            char ch = (char) (cell & 0xffffffffL);
            if (ch != ' ' && ch != 0) {
                hasContent = true;
                break;
            }
        }
        assertTrue(hasContent, "Terminal should contain written text");
    }

    @Test
    public void testSwingTerminalFrame() {
        // Skip this test in headless environments
        if (java.awt.GraphicsEnvironment.isHeadless()) {
            System.out.println("Skipping SwingTerminal frame test in headless environment");
            return;
        }

        JFrame frame = swingTerminal.createFrame("Test Terminal");
        assertNotNull(frame);
        assertEquals("Test Terminal", frame.getTitle());
        assertEquals(JFrame.EXIT_ON_CLOSE, frame.getDefaultCloseOperation());

        // Verify the component is added to the frame
        Component[] components = frame.getContentPane().getComponents();
        assertEquals(1, components.length);
        assertSame(swingTerminal.getComponent(), components[0]);

        // Clean up
        frame.dispose();
    }

    @Test
    public void testScreenTerminalBaseFunctionality() {
        // Test that both terminals inherit ScreenTerminal functionality

        // Test size setting
        assertTrue(webTerminal.setSize(30, 15));
        swingTerminal.setSize(new Size(30, 15));

        // Test writing
        assertTrue(webTerminal.write("Test content"));
        swingTerminal.write("Test content");

        // Add a small delay to ensure content is processed
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // Test that content appears in dump
        try {
            String webDump = webTerminal.dump(0, true);
            assertNotNull(webDump);
            assertTrue(webDump.contains("Test content"));

            String swingDump = swingTerminal.dump(0, true);
            assertNotNull(swingDump);
            assertTrue(swingDump.contains("Test content"));
        } catch (InterruptedException e) {
            fail("Dump should not be interrupted");
        }
    }

    @Test
    public void testAnsiColorSupport() {
        // Test ANSI color sequences
        String colorText = "\u001b[31mRed text\u001b[0m";
        webTerminal.write(colorText);
        swingTerminal.write(colorText);

        // Both should handle the escape sequences without errors
        assertDoesNotThrow(() -> {
            webTerminal.dump(0, true);
            swingTerminal.dump(0, true);
        });
    }

    @Test
    public void testCursorMovement() {
        // Test cursor positioning
        webTerminal.write("Hello");
        webTerminal.write("\u001b[1;1H"); // Move cursor to position 1,1
        webTerminal.write("X");

        swingTerminal.write("Hello");
        swingTerminal.write("\u001b[1;1H"); // Move cursor to position 1,1
        swingTerminal.write("X");

        // Verify that cursor movement worked
        assertDoesNotThrow(() -> {
            String webDump = webTerminal.dump(0, true);
            String swingDump = swingTerminal.dump(0, true);

            // Both dumps should contain the overwritten character
            assertNotNull(webDump);
            assertNotNull(swingDump);
        });
    }

    @Test
    public void testTerminalResizing() {
        // Test resizing functionality
        assertTrue(webTerminal.setSize(40, 20));
        swingTerminal.setSize(new Size(40, 20));

        // Write content after resize
        webTerminal.write("Resized terminal content");
        swingTerminal.write("Resized terminal content");

        // Verify content is still accessible
        assertDoesNotThrow(() -> {
            String webDump = webTerminal.dump(0, true);
            String swingDump = swingTerminal.dump(0, true);

            assertNotNull(webDump);
            assertNotNull(swingDump);
        });
    }

    @Test
    public void testInvalidSizes() {
        // Test that invalid sizes are rejected
        assertFalse(webTerminal.setSize(1, 10)); // Too small width
        assertFalse(webTerminal.setSize(10, 1)); // Too small height
        assertFalse(webTerminal.setSize(300, 10)); // Too large width
        assertFalse(webTerminal.setSize(10, 300)); // Too large height

        swingTerminal.setSize(new Size(1, 10));
        swingTerminal.setSize(new Size(10, 1));
        swingTerminal.setSize(new Size(300, 10));
        swingTerminal.setSize(new Size(10, 300));
    }
}
